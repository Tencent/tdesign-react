/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * 该文件由脚本自动生成，如需修改请联系 PMC
 * This file generated by scripts of tdesign-api. `npm run api:docs AutoComplete React(PC) vitest,finalProject`
 * If you need to modify this file, contact PMC first please.
 */
import React from 'react';
import { fireEvent, vi, render, mockDelay, simulateKeydownEvent } from '@test/utils';
import { AutoComplete } from '..';
import { getNormalAutoCompleteMount, getOptionSlotAutoCompleteMount } from './mount';

describe('AutoComplete Component', () => {
  it(`props.autofocus is equal to false`, () => {
    const { container } = render(<AutoComplete autofocus={false}></AutoComplete>);
    const domWrapper = container.querySelector('input');
    expect(domWrapper.getAttribute('autofocus')).toBeNull();
  });
  it(`props.autofocus is equal to true`, () => {
    const { container } = render(<AutoComplete autofocus={true}></AutoComplete>);
    const domWrapper = container.querySelector('input');
    expect(domWrapper.getAttribute('autofocus')).toBeDefined();
  });

  it('props.children works fine', () => {
    const { container } = render(
      <AutoComplete>
        <span className="custom-node">TNode</span>
      </AutoComplete>,
    );
    expect(container.querySelector('.custom-node')).toBeTruthy();
  });

  it('props.clearable: show clear icon on mouse enter', async () => {
    const { container } = getNormalAutoCompleteMount(AutoComplete, { value: 'Default Keyword', clearable: true });
    fireEvent.mouseEnter(container.querySelector('.t-input'));
    await mockDelay();
    expect(container.querySelector('.t-input__suffix-clear')).toBeTruthy();
  });
  it('props.clearable: expect trigger clear and change events after clear icon has been clicked', async () => {
    const onClearFn1 = vi.fn();
    const onChangeFn1 = vi.fn();
    const { container } = getNormalAutoCompleteMount(
      AutoComplete,
      { value: 'Default Keyword', clearable: true },
      { onClear: onClearFn1, onChange: onChangeFn1 },
    );
    fireEvent.mouseEnter(container.querySelector('.t-input'));
    await mockDelay();
    expect(container.querySelector('.t-input__suffix-clear')).toBeTruthy();
    fireEvent.click(container.querySelector('.t-input__suffix-clear'));
    expect(onClearFn1).toHaveBeenCalled(1);
    expect(onClearFn1.mock.calls[0][0].e.stopPropagation).toBeTruthy();
    expect(onClearFn1.mock.calls[0][0].e.type).toBe('click');
    expect(onChangeFn1).toHaveBeenCalled(1);
    expect(onChangeFn1.mock.calls[0][0]).toBe('');
    expect(onChangeFn1.mock.calls[0][1].e.stopPropagation).toBeTruthy();
    expect(onChangeFn1.mock.calls[0][1].e.type).toBe('click');
  });

  it('props.disabled works fine', () => {
    // disabled default value is
    const wrapper1 = render(<AutoComplete></AutoComplete>);
    const container1 = wrapper1.container.querySelector('.t-input');
    expect(container1.querySelector(`.${'t-is-disabled'}`)).toBeFalsy();
    // disabled = true
    const wrapper2 = render(<AutoComplete disabled={true}></AutoComplete>);
    const container2 = wrapper2.container.querySelector('.t-input');
    expect(container2).toHaveClass('t-is-disabled');
    // disabled = false
    const wrapper3 = render(<AutoComplete disabled={false}></AutoComplete>);
    const container3 = wrapper3.container.querySelector('.t-input');
    expect(container3.querySelector(`.${'t-is-disabled'}`)).toBeFalsy();
  });

  it('props.filter works fine', () => {
    const { container } = getNormalAutoCompleteMount(AutoComplete, {
      filter: (filterWords, option) => option.text.includes('Second'),
    });
    fireEvent.focus(container.querySelector('input'));
    const tSelectOptionDom = document.querySelectorAll('.t-select-option');
    expect(tSelectOptionDom.length).toBe(1);
  });

  it('props.filterable works fine', () => {
    const { container } = getNormalAutoCompleteMount(AutoComplete, { value: 'First', filterable: true });
    fireEvent.focus(container.querySelector('input'));
    const tSelectOptionDom = document.querySelectorAll('.t-select-option');
    expect(tSelectOptionDom.length).toBe(1);
  });

  it('props.highlightKeyword works fine', () => {
    const { container } = getNormalAutoCompleteMount(AutoComplete, { value: 'Second', highlightKeyword: true });
    fireEvent.focus(container.querySelector('input'));
    const tSelectOptionDom = document.querySelectorAll('.t-select-option');
    expect(tSelectOptionDom.length).toBe(1);
  });

  it('props.options: option.label could be defined to any element', () => {
    const { container } = getNormalAutoCompleteMount(AutoComplete);
    fireEvent.focus(container.querySelector('input'));
    const customNodeDom = document.querySelector('.custom-node');
    expect(customNodeDom).toBeTruthy();
  });
  it('props.options: 5 options should exist', () => {
    const { container } = getNormalAutoCompleteMount(AutoComplete);
    fireEvent.focus(container.querySelector('input'));
    const tSelectOptionDom = document.querySelectorAll('.t-select-option');
    expect(tSelectOptionDom.length).toBe(5);
  });
  it('props.options: expect empty options with no panel', () => {
    const { container } = render(
      <AutoComplete popupProps={{ overlayClassName: 'empty-options-class-name' }}></AutoComplete>,
    );
    fireEvent.focus(container.querySelector('input'));
    const emptyOptionsClassNameTAutocompletePanelDom = document.querySelectorAll(
      '.empty-options-class-name .t-autocomplete__panel',
    );
    expect(emptyOptionsClassNameTAutocompletePanelDom.length).toBe(0);
  });
  it('props.options: define one option', () => {
    const { container } = getOptionSlotAutoCompleteMount(AutoComplete, {
      popupProps: { overlayClassName: 'option-slot-class-name' },
    });
    fireEvent.focus(container.querySelector('input'));
    const optionSlotClassNameCustomSlotOptionDom = document.querySelector(
      '.option-slot-class-name .custom-slot-option',
    );
    expect(optionSlotClassNameCustomSlotOptionDom.textContent).toBe('First Keyword');
  });

  it('props.panelBottomContent works fine', () => {
    const { container } = render(
      <AutoComplete panelBottomContent={<span className="custom-node">TNode</span>}></AutoComplete>,
    );
    fireEvent.focus(container.querySelector('input'));
    const customNodeDom = document.querySelector('.custom-node');
    expect(customNodeDom).toBeTruthy();
    const tPopupDom = document.querySelector('.t-popup');
    expect(tPopupDom).toBeTruthy();
  });

  it('props.panelTopContent works fine', () => {
    const { container } = render(
      <AutoComplete panelTopContent={<span className="custom-node">TNode</span>}></AutoComplete>,
    );
    fireEvent.focus(container.querySelector('input'));
    const customNodeDom = document.querySelector('.custom-node');
    expect(customNodeDom).toBeTruthy();
    const tPopupDom = document.querySelector('.t-popup');
    expect(tPopupDom).toBeTruthy();
  });

  it(`props.placeholder is equal to 'type keyword to search'`, () => {
    const { container } = render(<AutoComplete placeholder="type keyword to search"></AutoComplete>);
    const domWrapper = container.querySelector('input');
    expect(domWrapper.getAttribute('placeholder')).toBe('type keyword to search');
  });

  it('props.popupProps works fine', () => {
    const { container } = getNormalAutoCompleteMount(AutoComplete, {
      popupProps: { overlayClassName: 'custom-class-name' },
    });
    fireEvent.focus(container.querySelector('input'));
    const customClassNameDom = document.querySelector('.custom-class-name');
    expect(customClassNameDom).toBeTruthy();
  });
  it('props.popupProps works fine', () => {
    const { container } = getNormalAutoCompleteMount(AutoComplete, {
      popupProps: { overlayInnerClassName: 'custom-class-name' },
    });
    fireEvent.focus(container.querySelector('input'));
    const customClassNameDom = document.querySelector('.custom-class-name');
    expect(customClassNameDom).toBeTruthy();
  });

  it('props.readonly works fine', () => {
    // readonly default value is
    const wrapper1 = getNormalAutoCompleteMount(AutoComplete);
    const container1 = wrapper1.container.querySelector('.t-input');
    expect(container1.querySelector(`.${'t-is-readonly'}`)).toBeFalsy();
    // readonly = true
    const wrapper2 = getNormalAutoCompleteMount(AutoComplete, { readonly: true });
    const container2 = wrapper2.container.querySelector('.t-input');
    expect(container2).toHaveClass('t-is-readonly');
    // readonly = false
    const wrapper3 = getNormalAutoCompleteMount(AutoComplete, { readonly: false });
    const container3 = wrapper3.container.querySelector('.t-input');
    expect(container3.querySelector(`.${'t-is-readonly'}`)).toBeFalsy();
  });

  const sizeClassNameList = ['t-size-s', { 't-size-m': false }, 't-size-l'];
  ['small', 'medium', 'large'].forEach((item, index) => {
    it(`props.size is equal to ${item}`, () => {
      const wrapper = getNormalAutoCompleteMount(AutoComplete, { size: item });
      const container = wrapper.container.querySelector('.t-input');
      if (typeof sizeClassNameList[index] === 'string') {
        expect(container).toHaveClass(sizeClassNameList[index]);
      } else if (typeof sizeClassNameList[index] === 'object') {
        const classNameKey = Object.keys(sizeClassNameList[index])[0];
        expect(container.querySelector(`.${classNameKey}`)).toBeFalsy();
      }
    });
  });

  const statusClassNameList = [{ 't-is-default': false }, 't-is-success', 't-is-warning', 't-is-error'];
  ['default', 'success', 'warning', 'error'].forEach((item, index) => {
    it(`props.status is equal to ${item}`, () => {
      const wrapper = getNormalAutoCompleteMount(AutoComplete, { status: item });
      const container = wrapper.container.querySelector('.t-input');
      if (typeof statusClassNameList[index] === 'string') {
        expect(container).toHaveClass(statusClassNameList[index]);
      } else if (typeof statusClassNameList[index] === 'object') {
        const classNameKey = Object.keys(statusClassNameList[index])[0];
        expect(container.querySelector(`.${classNameKey}`)).toBeFalsy();
      }
    });
  });

  it('props.tips is equal this is a tip', () => {
    const { container } = render(<AutoComplete tips="this is a tip"></AutoComplete>);
    expect(container.querySelector('.t-input__tips')).toBeTruthy();
  });

  it('props.triggerElement works fine', () => {
    const { container } = render(
      <AutoComplete triggerElement={<span className="custom-node">TNode</span>}></AutoComplete>,
    );
    expect(container.querySelector('.custom-node')).toBeTruthy();
  });

  it(`props.value is equal to 'DefaultKeyword'`, () => {
    const { container } = render(<AutoComplete value="DefaultKeyword"></AutoComplete>);
    const domWrapper = container.querySelector('input');
    expect(domWrapper.value).toBe('DefaultKeyword');
  });

  it('events.blur works fine', async () => {
    const onFocusFn = vi.fn();
    const onBlurFn1 = vi.fn();
    const { container } = getNormalAutoCompleteMount(AutoComplete, {}, { onFocus: onFocusFn, onBlur: onBlurFn1 });
    fireEvent.focus(container.querySelector('input'));
    expect(onFocusFn).toHaveBeenCalled(1);
    expect(onFocusFn.mock.calls[0][0].e.type).toBe('focus');
    fireEvent.blur(container.querySelector('input'));
    await mockDelay(300);
    expect(onBlurFn1).toHaveBeenCalled(1);
    expect(onBlurFn1.mock.calls[0][0].e.type).toBe('blur');
  });

  it('events.compositionend works fine', () => {
    const onCompositionendFn = vi.fn();
    const { container } = render(<AutoComplete onCompositionend={onCompositionendFn}></AutoComplete>);
    fireEvent.compositionEnd(container.querySelector('input'));
    expect(onCompositionendFn).toHaveBeenCalled(1);
    expect(onCompositionendFn.mock.calls[0][0].e.type).toBe('compositionend');
  });

  it('events.compositionstart works fine', () => {
    const onCompositionstartFn = vi.fn();
    const { container } = render(<AutoComplete onCompositionstart={onCompositionstartFn}></AutoComplete>);
    fireEvent.compositionStart(container.querySelector('input'));
    expect(onCompositionstartFn).toHaveBeenCalled(1);
    expect(onCompositionstartFn.mock.calls[0][0].e.type).toBe('compositionstart');
  });

  it('events.enter works fine', () => {
    const onEnterFn1 = vi.fn();
    const { container } = getNormalAutoCompleteMount(AutoComplete, {}, { onEnter: onEnterFn1 });
    fireEvent.focus(container.querySelector('input'));
    fireEvent.keyDown(container.querySelector('input'), { key: 'Enter', code: 'Enter', charCode: 13 });
    expect(onEnterFn1).toHaveBeenCalled(1);
    expect(onEnterFn1.mock.calls[0][0].e.type).toBe('keydown');
    expect(/Enter/i.test(onEnterFn1.mock.calls[0][0].e.key)).toBeTruthy();
  });

  it('events.focus works fine', () => {
    const onFocusFn = vi.fn();
    const { container } = getNormalAutoCompleteMount(AutoComplete, {}, { onFocus: onFocusFn });
    fireEvent.focus(container.querySelector('input'));
    expect(container.querySelector('.t-is-focused')).toBeTruthy();
    expect(onFocusFn).toHaveBeenCalled(1);
    expect(onFocusFn.mock.calls[0][0].e.type).toBe('focus');
  });

  it('events.select works fine', () => {
    const onSelectFn1 = vi.fn();
    const { container } = getNormalAutoCompleteMount(
      AutoComplete,
      { popupProps: { overlayClassName: 'select-event-class-name' } },
      { onSelect: onSelectFn1 },
    );
    fireEvent.focus(container.querySelector('input'));
    fireEvent.click(document.querySelector('.select-event-class-name .t-select-option'));
    expect(onSelectFn1).toHaveBeenCalled(1);
    expect(onSelectFn1.mock.calls[0][0]).toBe('FirstKeyword');
    expect(onSelectFn1.mock.calls[0][1].e.type).toBe('click');
  });
  it('events.select: keyboard operations: ArrowDown & ArrowUp & Enter', async () => {
    const onSelectFn6 = vi.fn();
    const { container } = getNormalAutoCompleteMount(AutoComplete, {}, { onSelect: onSelectFn6 });
    fireEvent.focus(container.querySelector('input'));
    simulateKeydownEvent(document, 'ArrowDown');
    await mockDelay(10);
    const domWrapper1 = document.querySelector('.t-select-option:first-child');
    expect(domWrapper1).toHaveClass('t-select-option--hover');
    simulateKeydownEvent(document, 'ArrowDown');
    await mockDelay(10);
    const domWrapper2 = document.querySelector('.t-select-option:nth-child(2)');
    expect(domWrapper2).toHaveClass('t-select-option--hover');
    simulateKeydownEvent(document, 'ArrowUp');
    await mockDelay(10);
    const domWrapper3 = document.querySelector('.t-select-option:first-child');
    expect(domWrapper3).toHaveClass('t-select-option--hover');
    simulateKeydownEvent(document, 'ArrowUp');
    await mockDelay(10);
    const domWrapper4 = document.querySelector('.t-select-option:nth-child(5)');
    expect(domWrapper4).toHaveClass('t-select-option--hover');
    simulateKeydownEvent(document, 'ArrowDown');
    await mockDelay(10);
    const domWrapper5 = document.querySelector('.t-select-option:first-child');
    expect(domWrapper5).toHaveClass('t-select-option--hover');
    simulateKeydownEvent(document, 'Enter');
    expect(onSelectFn6).toHaveBeenCalled(1);
    expect(onSelectFn6.mock.calls[0][0]).toBe('FirstKeyword');
    expect(onSelectFn6.mock.calls[0][1].e.type).toBe('keydown');
  });
});
