/**
 * 该文件由脚本自动生成，如需修改请联系 PMC
 * This file generated by scripts of tdesign-api. `npm run api:docs AutoComplete React(PC) vitest,finalProject`
 * If you need to modify this file, contact PMC first please.
 */
import React from 'react';
import { fireEvent, vi, render, mockDelay } from '@test/utils';
import { AutoComplete } from '..';
import { getNormalAutoCompleteMount } from './mount';

describe('AutoComplete Component', () => {
  it(`props.autofocus is equal to false`, () => {
    const { container } = render(<AutoComplete autofocus={false}></AutoComplete>);
    const domWrapper = container.querySelector('input');
    expect(domWrapper.getAttribute('autofocus')).toBeNull();
  });
  it(`props.autofocus is equal to true`, () => {
    const { container } = render(<AutoComplete autofocus={true}></AutoComplete>);
    const domWrapper = container.querySelector('input');
    expect(domWrapper.getAttribute('autofocus')).toBeDefined();
  });

  it('props.children works fine', () => {
    const { container } = render(
      <AutoComplete>
        <span className="custom-node">TNode</span>
      </AutoComplete>,
    );
    expect(container.querySelector('.custom-node')).toBeTruthy();
  });

  it('props.clearable: show clear icon on mouse enter', async () => {
    const { container } = getNormalAutoCompleteMount(AutoComplete, { value: 'Default Keyword', clearable: true });
    fireEvent.mouseEnter(container.querySelector('.t-input'));
    await mockDelay();
    expect(container.querySelector('.t-input__suffix-clear')).toBeTruthy();
  });
  it('props.clearable: expect trigger clear and change events after clear icon has been clicked', async () => {
    const onClearFn1 = vi.fn();
    const onChangeFn1 = vi.fn();
    const { container } = getNormalAutoCompleteMount(
      AutoComplete,
      { value: 'Default Keyword', clearable: true },
      { onClear: onClearFn1, onChange: onChangeFn1 },
    );
    fireEvent.mouseEnter(container.querySelector('.t-input'));
    await mockDelay();
    expect(container.querySelector('.t-input__suffix-clear')).toBeTruthy();
    fireEvent.click(container.querySelector('.t-input__suffix-clear'));
    expect(onClearFn1).toHaveBeenCalled();
    expect(onClearFn1.mock.calls[0][0].e.stopPropagation).toBeTruthy();
    expect(onClearFn1.mock.calls[0][0].e.type).toBe('click');
    expect(onChangeFn1).toHaveBeenCalled();
    expect(onChangeFn1.mock.calls[0][0]).toBe('');
    expect(onChangeFn1.mock.calls[0][1].e.stopPropagation).toBeTruthy();
    expect(onChangeFn1.mock.calls[0][1].e.type).toBe('click');
  });

  it('props.disabled works fine', () => {
    // disabled default value is
    const wrapper1 = render(<AutoComplete></AutoComplete>);
    const container1 = wrapper1.container.querySelector('.t-input');
    expect(container1.querySelector(`.${'t-is-disabled'}`)).toBeFalsy();
    // disabled = true
    const wrapper2 = render(<AutoComplete disabled={true}></AutoComplete>);
    const container2 = wrapper2.container.querySelector('.t-input');
    expect(container2).toHaveClass('t-is-disabled');
    // disabled = false
    const wrapper3 = render(<AutoComplete disabled={false}></AutoComplete>);
    const container3 = wrapper3.container.querySelector('.t-input');
    expect(container3.querySelector(`.${'t-is-disabled'}`)).toBeFalsy();
  });

  it('props.filter works fine', () => {
    const { container } = getNormalAutoCompleteMount(AutoComplete, {
      filter: (filterWords, option) => option.text.includes('Second'),
    });
    fireEvent.focus(container.querySelector('input'));
    const tSelectOptionDom = document.querySelectorAll('.t-select-option');
    expect(tSelectOptionDom.length).toBe(1);
  });

  it('props.filterable works fine', () => {
    const { container } = getNormalAutoCompleteMount(AutoComplete, { value: 'First', filterable: true });
    fireEvent.focus(container.querySelector('input'));
    const tSelectOptionDom = document.querySelectorAll('.t-select-option');
    expect(tSelectOptionDom.length).toBe(1);
  });

  it('props.highlightKeyword works fine', () => {
    const { container } = getNormalAutoCompleteMount(AutoComplete, { value: 'Second', highlightKeyword: true });
    fireEvent.focus(container.querySelector('input'));
    const tSelectOptionDom = document.querySelectorAll('.t-select-option');
    expect(tSelectOptionDom.length).toBe(1);
  });

  it('props.options: option.label could be defined to any element', () => {
    const { container } = getNormalAutoCompleteMount(AutoComplete);
    fireEvent.focus(container.querySelector('input'));
    const customNodeDom = document.querySelector('.custom-node');
    expect(customNodeDom).toBeDefined();
  });
  it('props.options: 3 options should exist', () => {
    const { container } = getNormalAutoCompleteMount(AutoComplete);
    fireEvent.focus(container.querySelector('input'));
    const tSelectOptionDom = document.querySelectorAll('.t-select-option');
    expect(tSelectOptionDom.length).toBe(3);
  });

  it('props.panelBottomContent works fine', () => {
    const { container } = render(
      <AutoComplete panelBottomContent={<span className="custom-node">TNode</span>}></AutoComplete>,
    );
    fireEvent.focus(container.querySelector('input'));
    const customNodeDom = document.querySelector('.custom-node');
    expect(customNodeDom).toBeDefined();
    const tPopupDom = document.querySelector('.t-popup');
    expect(tPopupDom).toBeDefined();
  });

  it('props.panelTopContent works fine', () => {
    const { container } = render(
      <AutoComplete panelTopContent={<span className="custom-node">TNode</span>}></AutoComplete>,
    );
    fireEvent.focus(container.querySelector('input'));
    const customNodeDom = document.querySelector('.custom-node');
    expect(customNodeDom).toBeDefined();
    const tPopupDom = document.querySelector('.t-popup');
    expect(tPopupDom).toBeDefined();
  });

  it(`props.placeholder is equal to 'type keyword to search'`, () => {
    const { container } = render(<AutoComplete placeholder={'type keyword to search'}></AutoComplete>);
    const domWrapper = container.querySelector('input');
    expect(domWrapper.getAttribute('placeholder')).toBe('type keyword to search');
  });

  it('props.readonly works fine', () => {
    // readonly default value is
    const wrapper1 = getNormalAutoCompleteMount(AutoComplete);
    const container1 = wrapper1.container.querySelector('.t-input');
    expect(container1.querySelector(`.${'t-is-readonly'}`)).toBeFalsy();
    // readonly = true
    const wrapper2 = getNormalAutoCompleteMount(AutoComplete, { readonly: true });
    const container2 = wrapper2.container.querySelector('.t-input');
    expect(container2).toHaveClass('t-is-readonly');
    // readonly = false
    const wrapper3 = getNormalAutoCompleteMount(AutoComplete, { readonly: false });
    const container3 = wrapper3.container.querySelector('.t-input');
    expect(container3.querySelector(`.${'t-is-readonly'}`)).toBeFalsy();
  });

  const sizeClassNameList = ['t-size-s', { 't-size-m': false }, 't-size-l'];
  ['small', 'medium', 'large'].forEach((item, index) => {
    it(`props.size is equal to ${item}`, () => {
      const wrapper = getNormalAutoCompleteMount(AutoComplete, { size: item });
      const container = wrapper.container.querySelector('.t-input');
      if (typeof sizeClassNameList[index] === 'string') {
        expect(container).toHaveClass(sizeClassNameList[index]);
      } else if (typeof sizeClassNameList[index] === 'object') {
        const classNameKey = Object.keys(sizeClassNameList[index])[0];
        expect(container.querySelector(`.${classNameKey}`)).toBeFalsy();
      }
    });
  });

  ['default', 'success', 'warning', 'error'].forEach((item) => {
    it(`props.status is equal to ${item}`, () => {
      const wrapper = getNormalAutoCompleteMount(AutoComplete, { status: item });
      const container = wrapper.container.querySelector('.t-input');
      expect(container).toHaveClass(`t-is-${item}`);
    });
  });

  it('props.tips is equal this is a tip', () => {
    const { container } = render(<AutoComplete tips={'this is a tip'}></AutoComplete>);
    expect(container.querySelector('.t-input__tips')).toBeTruthy();
  });

  it('props.triggerElement works fine', () => {
    const { container } = render(
      <AutoComplete triggerElement={<span className="custom-node">TNode</span>}></AutoComplete>,
    );
    expect(container.querySelector('.custom-node')).toBeTruthy();
  });

  it(`props.value is equal to 'DefaultKeyword'`, () => {
    const { container } = render(<AutoComplete value={'DefaultKeyword'}></AutoComplete>);
    const domWrapper = container.querySelector('input');
    expect(domWrapper.value).toBe('DefaultKeyword');
  });

  it('events.blur works fine', async () => {
    const onFocusFn = vi.fn();
    const onBlurFn1 = vi.fn();
    const { container } = getNormalAutoCompleteMount(AutoComplete, {}, { onFocus: onFocusFn, onBlur: onBlurFn1 });
    fireEvent.focus(container.querySelector('input'));
    expect(onFocusFn).toHaveBeenCalled();
    expect(onFocusFn.mock.calls[0][0].e.type).toBe('focus');
    fireEvent.blur(container.querySelector('input'));
    await mockDelay(300);
    expect(onBlurFn1).toHaveBeenCalled();
    expect(onBlurFn1.mock.calls[0][0].e.type).toBe('blur');
  });

  it('events.enter works fine', () => {
    const onEnterFn1 = vi.fn();
    const { container } = getNormalAutoCompleteMount(AutoComplete, {}, { onEnter: onEnterFn1 });
    fireEvent.focus(container.querySelector('input'));
    fireEvent.keyDown(container.querySelector('input'), { key: 'Enter', code: 'Enter', charCode: 13 });
    expect(onEnterFn1).toHaveBeenCalled();
    expect(onEnterFn1.mock.calls[0][0].e.type).toBe('keydown');
    expect(/Enter/i.test(onEnterFn1.mock.calls[0][0].e.key)).toBeTruthy();
  });

  it('events.focus works fine', () => {
    const onFocusFn = vi.fn();
    const { container } = getNormalAutoCompleteMount(AutoComplete, {}, { onFocus: onFocusFn });
    fireEvent.focus(container.querySelector('input'));
    expect(container.querySelector('.t-is-focused')).toBeTruthy();
    expect(onFocusFn).toHaveBeenCalled();
    expect(onFocusFn.mock.calls[0][0].e.type).toBe('focus');
  });
});
