/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * 该文件由脚本自动生成，如需修改请联系 PMC
 * This file generated by scripts of tdesign-api. `npm run api:docs Input React(PC) vitest,finalProject`
 * If you need to modify this file, contact PMC first please.
 */
import React from 'react';
import { fireEvent, vi, render, mockDelay, simulateInputChange } from '@test/utils';
import { Input, InputGroup } from '..';
import { getInputGroupDefaultMount } from './mount';

describe('Input Component', () => {
  const alignClassNameList = [{ 't-align-left': false }, 't-align-center', 't-align-right'];
  ['left', 'center', 'right'].forEach((item, index) => {
    it(`props.align is equal to ${item}`, () => {
      const wrapper = render(<Input align={item}></Input>);
      const container = wrapper.container.querySelector('.t-input');
      if (typeof alignClassNameList[index] === 'string') {
        expect(container).toHaveClass(alignClassNameList[index]);
      } else if (typeof alignClassNameList[index] === 'object') {
        const classNameKey = Object.keys(alignClassNameList[index])[0];
        expect(container.querySelector(`.${classNameKey}`)).toBeFalsy();
      }
      expect(container).toMatchSnapshot();
    });
  });

  it('props.allowInputOverMax works fine', () => {
    const { container } = render(<Input value="Hello" maxlength={5} allowInputOverMax={true}></Input>);
    const inputDom = container.querySelector('input');
    simulateInputChange(inputDom, 'Hello TDesign');
    const attrDom = container.querySelector('input');
    expect(attrDom.value).toBe('Hello');
  });

  it('props.autocomplete works fine', () => {
    const wrapper = render(<Input autocomplete="https://tdesign.tencent.com/"></Input>);
    const container = wrapper.container.querySelector('input');
    expect(container.getAttribute('autocomplete')).toBe('https://tdesign.tencent.com/');
  });

  it(`props.autofocus is equal to false`, () => {
    const { container } = render(<Input autofocus={false}></Input>);
    const domWrapper = container.querySelector('input');
    expect(domWrapper.getAttribute('autofocus')).toBeNull();
  });
  it(`props.autofocus is equal to true`, () => {
    const { container } = render(<Input autofocus={true}></Input>);
    const domWrapper = container.querySelector('input');
    expect(domWrapper.getAttribute('autofocus')).toBeDefined();
  });

  it('props.clearable: clear icon should exist on input mouseenter', async () => {
    const { container } = render(<Input value="Default Keyword" clearable={true}></Input>);
    fireEvent.mouseEnter(container.querySelector('.t-input'));
    await mockDelay();
    expect(container.querySelector('.t-input__suffix-clear')).toBeTruthy();
  });

  it('props.clearable: click clear icon could clear input value to be empty', async () => {
    const onClearFn1 = vi.fn();
    const onChangeFn1 = vi.fn();
    const { container } = render(
      <Input value="Default Keyword" clearable={true} onClear={onClearFn1} onChange={onChangeFn1}></Input>,
    );
    fireEvent.mouseEnter(container.querySelector('.t-input'));
    await mockDelay(300);
    expect(container.querySelector('.t-input__suffix-clear')).toBeTruthy();
    fireEvent.click(container.querySelector('.t-input__suffix-clear'));
    expect(onClearFn1).toHaveBeenCalled();
    expect(onClearFn1.mock.calls[0][0].e.stopPropagation).toBeTruthy();
    expect(onClearFn1.mock.calls[0][0].e.type).toBe('click');
    expect(onChangeFn1).toHaveBeenCalled();
    expect(onChangeFn1.mock.calls[0][0]).toBe('');
    expect(onChangeFn1.mock.calls[0][1].e.stopPropagation).toBeTruthy();
    expect(onChangeFn1.mock.calls[0][1].e.type).toBe('click');
  });

  it('props.clearable: type=password, browseIcon and clearableIcon works fine', async () => {
    const { container } = render(<Input type="password" value="this is my password" clearable={true}></Input>);
    expect(container.querySelector('.t-icon-browse-off')).toBeTruthy();
    fireEvent.mouseEnter(container.querySelector('.t-input'));
    await mockDelay(300);
    expect(container.querySelector('.t-input__suffix-clear')).toBeTruthy();
  });

  it('props.disabled works fine', () => {
    // disabled default value is
    const wrapper1 = render(<Input></Input>);
    const container1 = wrapper1.container.querySelector('.t-input');
    expect(container1.querySelector(`.${'t-is-disabled'}`)).toBeFalsy();
    // disabled = true
    const wrapper2 = render(<Input disabled={true}></Input>);
    const container2 = wrapper2.container.querySelector('.t-input');
    expect(container2).toHaveClass('t-is-disabled');
    // disabled = false
    const wrapper3 = render(<Input disabled={false}></Input>);
    const container3 = wrapper3.container.querySelector('.t-input');
    expect(container3.querySelector(`.${'t-is-disabled'}`)).toBeFalsy();
  });

  it('props.format: focus and blur states have different value', () => {
    const { container } = render(<Input format={(val) => `${val} 元`} value="100"></Input>);
    fireEvent.focus(container.querySelector('input'));
    const attrDom = container.querySelector('input');
    expect(attrDom.value).toBe('100');
    fireEvent.blur(container.querySelector('input'));
    const attrDom1 = container.querySelector('input');
    expect(attrDom1.value).toBe('100 元');
  });

  it(`props.inputClass is equal to name1 name2`, () => {
    const { container } = render(<Input inputClass="name1 name2"></Input>);
    const domWrapper = container.querySelector('.t-input');
    expect(domWrapper).toHaveClass('name1');
    expect(domWrapper).toHaveClass('name2');
  });
  it(`props.inputClass is equal to ['name1', 'name2']`, () => {
    const { container } = render(<Input inputClass={['name1', 'name2']}></Input>);
    const domWrapper = container.querySelector('.t-input');
    expect(domWrapper).toHaveClass('name1');
    expect(domWrapper).toHaveClass('name2');
  });
  it(`props.inputClass is equal to { name1: true, name2: false }`, () => {
    const { container } = render(<Input inputClass={{ name1: true, name2: false }}></Input>);
    const domWrapper = container.querySelector('.t-input');
    expect(domWrapper).toHaveClass('name1');
    expect(domWrapper.classList.contains('name2')).toBeFalsy();
  });

  it('props.label works fine', () => {
    const { container } = render(<Input label={<span className="custom-node">TNode</span>}></Input>);
    expect(container.querySelector('.custom-node')).toBeTruthy();
    expect(container.querySelector('.t-input__prefix')).toBeTruthy();
    expect(container).toMatchSnapshot();
  });

  it('props.maxcharacter: length of value is over than maxcharacter', () => {
    const onChangeFn = vi.fn();
    const { container } = render(<Input value="你好 TDesign" maxcharacter={4} onChange={onChangeFn}></Input>);
    expect(onChangeFn).toHaveBeenCalled();
    expect(onChangeFn.mock.calls[0][0]).toBe('你好');
    expect(onChangeFn.mock.calls[0][1].trigger).toBe('initial');
  });

  it('props.maxlength: length of value is over than maxlength', () => {
    const onChangeFn = vi.fn();
    const { container } = render(<Input value="Hello TDesign" maxlength={5} onChange={onChangeFn}></Input>);
    expect(onChangeFn).toHaveBeenCalled();
    expect(onChangeFn.mock.calls[0][0]).toBe('Hello');
    expect(onChangeFn.mock.calls[0][1].trigger).toBe('initial');
  });

  it('props.name works fine', () => {
    const wrapper = render(<Input name="input-name"></Input>);
    const container = wrapper.container.querySelector('input');
    expect(container.getAttribute('name')).toBe('input-name');
  });

  it('props.placeholder works fine', () => {
    const wrapper = render(<Input placeholder="this is input placeholder"></Input>);
    const container = wrapper.container.querySelector('input');
    expect(container.getAttribute('placeholder')).toBe('this is input placeholder');
  });

  it('props.prefixIcon works fine', () => {
    const { container } = render(<Input prefixIcon={<span className="custom-node">TNode</span>}></Input>);
    expect(container.querySelector('.custom-node')).toBeTruthy();
    expect(container.querySelector('.t-input__prefix-icon')).toBeTruthy();
  });

  it('props.readonly works fine', () => {
    // readonly default value is false
    const wrapper1 = render(<Input></Input>);
    const container1 = wrapper1.container.querySelector('.t-input');
    expect(container1.querySelector(`.${'t-is-readonly'}`)).toBeFalsy();
    // readonly = true
    const wrapper2 = render(<Input readonly={true}></Input>);
    const container2 = wrapper2.container.querySelector('.t-input');
    expect(container2).toHaveClass('t-is-readonly');
    // readonly = false
    const wrapper3 = render(<Input readonly={false}></Input>);
    const container3 = wrapper3.container.querySelector('.t-input');
    expect(container3.querySelector(`.${'t-is-readonly'}`)).toBeFalsy();
  });

  it('props.showClearIconOnEmpty works fine', async () => {
    const { container } = render(<Input showClearIconOnEmpty={true}></Input>);
    fireEvent.mouseEnter(container.querySelector('.t-input'));
    await mockDelay();
    expect(container.querySelector('.t-input__suffix-clear')).toBeTruthy();
  });

  it('props.showLimitNumber works fine. `{".t-input__limit-number":{"text":"2/5"}}` should exist', () => {
    const { container } = render(<Input showLimitNumber={true} maxlength={5} value="TD"></Input>);
    expect(container.querySelector('.t-input__limit-number').textContent).toBe('2/5');
  });

  const sizeClassNameList = ['t-size-s', { 't-size-m': false }, 't-size-l'];
  ['small', 'medium', 'large'].forEach((item, index) => {
    it(`props.size is equal to ${item}`, () => {
      const wrapper = render(<Input size={item}></Input>);
      const container = wrapper.container.querySelector('.t-input');
      if (typeof sizeClassNameList[index] === 'string') {
        expect(container).toHaveClass(sizeClassNameList[index]);
      } else if (typeof sizeClassNameList[index] === 'object') {
        const classNameKey = Object.keys(sizeClassNameList[index])[0];
        expect(container.querySelector(`.${classNameKey}`)).toBeFalsy();
      }
    });
  });

  const statusClassNameList = [{ 't-is-default': false }, 't-is-success', 't-is-warning', 't-is-error'];
  ['default', 'success', 'warning', 'error'].forEach((item, index) => {
    it(`props.status is equal to ${item}`, () => {
      const wrapper = render(<Input status={item}></Input>);
      const container = wrapper.container.querySelector('.t-input');
      if (typeof statusClassNameList[index] === 'string') {
        expect(container).toHaveClass(statusClassNameList[index]);
      } else if (typeof statusClassNameList[index] === 'object') {
        const classNameKey = Object.keys(statusClassNameList[index])[0];
        expect(container.querySelector(`.${classNameKey}`)).toBeFalsy();
      }
      expect(container).toMatchSnapshot();
    });
  });

  it('props.suffix works fine', () => {
    const { container } = render(<Input suffix={<span className="custom-node">TNode</span>}></Input>);
    expect(container.querySelector('.custom-node')).toBeTruthy();
    expect(container.querySelector('.t-input__suffix')).toBeTruthy();
    expect(container).toMatchSnapshot();
  });

  it('props.suffixIcon works fine', () => {
    const { container } = render(<Input suffixIcon={<span className="custom-node">TNode</span>}></Input>);
    expect(container.querySelector('.custom-node')).toBeTruthy();
    expect(container.querySelector('.t-input__suffix-icon')).toBeTruthy();
    expect(container).toMatchSnapshot();
  });

  it('props.tips is equal this is a tip', () => {
    const { container } = render(<Input tips="this is a tip"></Input>);
    expect(container.querySelectorAll('.t-input__tips').length).toBe(1);
  });

  const attributeValues = ['text', 'number', 'url', 'tel', 'password', 'search', 'submit', 'hidden'];
  ['text', 'number', 'url', 'tel', 'password', 'search', 'submit', 'hidden'].forEach((item, index) => {
    it(`props.type is equal to ${item}`, () => {
      const wrapper = render(<Input type={item}></Input>);
      const container = wrapper.container.querySelector('input');
      expect(container.getAttribute('type')).toBe(attributeValues[index]);
    });
  });

  it('props.type is equal password', () => {
    const { container } = render(<Input type="password"></Input>);
    expect(container.querySelectorAll('.t-icon-browse-off').length).toBe(1);
  });

  it('props.type: password could be visible by click browse icon', () => {
    const { container } = render(<Input type="password"></Input>);
    fireEvent.click(container.querySelector('.t-icon-browse-off'));
    expect(container.querySelector('.t-icon-browse')).toBeTruthy();
    const attrDom = container.querySelector('input');
    expect(attrDom.getAttribute('type')).toBe('text');
    fireEvent.click(container.querySelector('.t-icon-browse'));
    expect(container.querySelector('.t-icon-browse-off')).toBeTruthy();
    const attrDom1 = container.querySelector('input');
    expect(attrDom1.getAttribute('type')).toBe('password');
  });

  it('events.blur works fine', async () => {
    const onFocusFn = vi.fn();
    const onBlurFn1 = vi.fn();
    const { container } = render(<Input value="initial-input-value" onFocus={onFocusFn} onBlur={onBlurFn1}></Input>);
    fireEvent.focus(container.querySelector('input'));
    expect(onFocusFn).toHaveBeenCalled();
    expect(onFocusFn.mock.calls[0][0]).toBe('initial-input-value');
    expect(onFocusFn.mock.calls[0][1].e.type).toBe('focus');
    fireEvent.blur(container.querySelector('input'));
    await mockDelay(300);
    expect(onBlurFn1).toHaveBeenCalled();
    expect(onBlurFn1.mock.calls[0][0]).toBe('initial-input-value');
    expect(onBlurFn1.mock.calls[0][1].e.type).toBe('blur');
  });

  it('events.change: empty value could trigger change event', () => {
    const onChangeFn = vi.fn();
    const { container } = render(<Input onChange={onChangeFn}></Input>);
    const inputDom = container.querySelector('input');
    simulateInputChange(inputDom, 'initial value');
    expect(onChangeFn).toHaveBeenCalled();
    expect(onChangeFn.mock.calls[0][0]).toBe('initial value');
    expect(onChangeFn.mock.calls[0][1].e.type).toBe('change');
  });

  it('events.change: controlled value test', () => {
    const onChangeFn = vi.fn();
    const { container } = render(<Input value="TDesign" onChange={onChangeFn}></Input>);
    const inputDom = container.querySelector('input');
    simulateInputChange(inputDom, 'Hello TDesign');
    const attrDom = container.querySelector('input');
    expect(attrDom.value).toBe('TDesign');
    expect(onChangeFn).toHaveBeenCalled();
    expect(onChangeFn.mock.calls[0][0]).toBe('Hello TDesign');
    expect(onChangeFn.mock.calls[0][1].e.type).toBe('change');
  });

  it('events.change: uncontrolled value test', () => {
    const onChangeFn = vi.fn();
    const { container } = render(<Input defaultValue="Hello" onChange={onChangeFn}></Input>);
    const inputDom = container.querySelector('input');
    simulateInputChange(inputDom, 'Hello TDesign');
    const attrDom = container.querySelector('input');
    expect(attrDom.value).toBe('Hello TDesign');
    expect(onChangeFn).toHaveBeenCalled();
    expect(onChangeFn.mock.calls[0][0]).toBe('Hello TDesign');
    expect(onChangeFn.mock.calls[0][1].e.type).toBe('change');
  });

  it('events.click works fine', () => {
    const fn = vi.fn();
    const { container } = render(<Input onClick={fn}></Input>);
    fireEvent.click(container.querySelector('.t-input'));
    expect(fn).toHaveBeenCalled();
    expect(fn.mock.calls[0][0].e.type).toBe('click');
  });

  it('events.compositionend works fine', () => {
    const onCompositionendFn = vi.fn();
    const { container } = render(<Input value="输入结束" onCompositionend={onCompositionendFn}></Input>);
    fireEvent.compositionEnd(container.querySelector('input'));
    expect(onCompositionendFn).toHaveBeenCalled();
    expect(onCompositionendFn.mock.calls[0][0]).toBe('输入结束');
    expect(onCompositionendFn.mock.calls[0][1].e.type).toBe('compositionend');
  });

  it('events.compositionstart works fine', () => {
    const onCompositionstartFn = vi.fn();
    const { container } = render(<Input value="输入开始" onCompositionstart={onCompositionstartFn}></Input>);
    fireEvent.compositionStart(container.querySelector('input'));
    expect(onCompositionstartFn).toHaveBeenCalled();
    expect(onCompositionstartFn.mock.calls[0][0]).toBe('输入开始');
    expect(onCompositionstartFn.mock.calls[0][1].e.type).toBe('compositionstart');
  });

  it('events.enter works fine', () => {
    const onEnterFn1 = vi.fn();
    const { container } = render(<Input value="text" onEnter={onEnterFn1}></Input>);
    fireEvent.focus(container.querySelector('input'));
    fireEvent.keyDown(container.querySelector('input'), { key: 'Enter', code: 'Enter', charCode: 13 });
    expect(onEnterFn1).toHaveBeenCalled();
    expect(onEnterFn1.mock.calls[0][0]).toBe('text');
    expect(onEnterFn1.mock.calls[0][1].e.type).toBe('keydown');
  });

  it('events.focus works fine', () => {
    const onFocusFn = vi.fn();
    const { container } = render(<Input onFocus={onFocusFn}></Input>);
    fireEvent.focus(container.querySelector('input'));
    expect(onFocusFn).toHaveBeenCalled();
    expect(onFocusFn.mock.calls[0][0]).toBe('');
    expect(onFocusFn.mock.calls[0][1].e.type).toBe('focus');
  });

  it('events.keydown works fine', () => {
    const onKeydownFn = vi.fn();
    const { container } = render(<Input value="text" onKeydown={onKeydownFn}></Input>);
    fireEvent.keyDown(container.querySelector('input'));
    expect(onKeydownFn).toHaveBeenCalled();
    expect(onKeydownFn.mock.calls[0][0]).toBe('text');
    expect(onKeydownFn.mock.calls[0][1].e.type).toBe('keydown');
  });

  it('events.keypress works fine', () => {
    const onKeydownFn = vi.fn();
    const { container } = render(<Input value="text" onKeydown={onKeydownFn}></Input>);
    fireEvent.keyDown(container.querySelector('input'));
    expect(onKeydownFn).toHaveBeenCalled();
    expect(onKeydownFn.mock.calls[0][0]).toBe('text');
    expect(onKeydownFn.mock.calls[0][1].e.type).toBe('keydown');
  });

  it('events.keyup works fine', () => {
    const onKeyupFn = vi.fn();
    const { container } = render(<Input value="text" onKeyup={onKeyupFn}></Input>);
    fireEvent.keyUp(container.querySelector('input'));
    expect(onKeyupFn).toHaveBeenCalled();
    expect(onKeyupFn.mock.calls[0][0]).toBe('text');
    expect(onKeyupFn.mock.calls[0][1].e.type).toBe('keyup');
  });

  it('events.mouseenter works fine', async () => {
    const onMouseenterFn = vi.fn();
    const { container } = render(<Input onMouseenter={onMouseenterFn}></Input>);
    fireEvent.mouseEnter(container.querySelector('.t-input'));
    await mockDelay();
    expect(onMouseenterFn).toHaveBeenCalled();
    expect(onMouseenterFn.mock.calls[0][0].e.type).toBe('mouseenter');
  });

  it('events.mouseleave works fine', async () => {
    const onMouseleaveFn = vi.fn();
    const { container } = render(<Input onMouseleave={onMouseleaveFn}></Input>);
    fireEvent.mouseLeave(container.querySelector('.t-input'));
    await mockDelay();
    expect(onMouseleaveFn).toHaveBeenCalled();
    expect(onMouseleaveFn.mock.calls[0][0].e.type).toBe('mouseleave');
  });

  it('events.paste works fine', () => {
    const onPasteFn = vi.fn();
    const { container } = render(<Input onPaste={onPasteFn}></Input>);
    fireEvent.paste(container.querySelector('input'));
    expect(onPasteFn).toHaveBeenCalled();
    expect(onPasteFn.mock.calls[0][0].e.type).toBe('paste');
  });

  it('events.validate works fine', () => {
    const onValidateFn = vi.fn();
    const { container } = render(<Input value="Hello World" maxlength={5} onValidate={onValidateFn}></Input>);
    expect(onValidateFn).toHaveBeenCalled();
    expect(onValidateFn.mock.calls[0][0].error).toBe('exceed-maximum');
  });

  it('events.wheel works fine', () => {
    const onWheelFn = vi.fn();
    const { container } = render(<Input onWheel={onWheelFn}></Input>);
    fireEvent.wheel(container.querySelector('input'));
    expect(onWheelFn).toHaveBeenCalled();
    expect(onWheelFn.mock.calls[0][0].e.type).toBe('wheel');
  });
});

describe('InputGroup Component', () => {
  it('props.separate works fine', () => {
    // separate default value is
    const { container: container1 } = getInputGroupDefaultMount(InputGroup);
    expect(container1.querySelector(`.${'t-input-group--separate'}`)).toBeFalsy();
    // separate = true
    const { container: container2 } = getInputGroupDefaultMount(InputGroup, { separate: true });
    expect(container2.firstChild).toHaveClass('t-input-group--separate');
    // separate = false
    const { container: container3 } = getInputGroupDefaultMount(InputGroup, { separate: false });
    expect(container3.querySelector(`.${'t-input-group--separate'}`)).toBeFalsy();
  });
});
