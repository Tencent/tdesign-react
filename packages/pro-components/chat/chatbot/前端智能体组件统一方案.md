# 前端智能体组件统一方案

## 1. 目标与背景

### 背景

未来主流的 Agent 交互形态将由一个核心对话界面（通常位于一侧）和数据呈现/工作区（位于另一侧）构成。用户与 Agent 的所有核心交互都在对话流中完成。当需要展示复杂信息或需要用户进行结构化输入时，Agent 会通过调用工具（Tools）的方式，在前端应用中唤起一个或多个 UI 组件。这些组件负责为用户呈现信息或请求用户反馈，并将结果返回给 Agent，从而驱动对话继续进行。
![image](https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MDMyNjI1MjEwMA_712142_aDMxDV5ItJ8F92qs_1754443296?w=1553&h=1231&type=image/png)
上图展示了这种典型的交互模式：右侧是对话流，其中内嵌了 Agent 唤起的用于信息收集（联系方式）和信息展示（可选车辆）的前端组件；左侧是根据交互结果更新的数据呈现面板。

### 目标

本方案旨在为这种交互模式下的前端组件提供一套统一、高效的开发规范。目标是实现组件逻辑与 UI 的高度内聚，并简化开发者在为 AI Agent 创建前端工具时的开发体验。通过一个智能适配器，遵循本规范的组件可以无缝接入 CopilotKit 或其他兼容智能体 UI 协议的宿主环境。

## 2. 核心设计：统一的 Action 配置对象

为了解决非交互式场景下 handler 与 component 分离的问题，我们引入一个统一的 Action 配置对象 (AgentToolcallConfig)。一个 Action 的所有相关逻辑——包括元数据、业务逻辑 (handler) 和 UI 逻辑 (component)——都封装在这个单一的对象中，实现了高度内聚。
适配器会根据此配置对象中是否存在 handler 属性，来智能地决定其行为模式。

## 3. 技术规范

### 3.1. 组件 Props 接口：ToolcallComponentProps

这是所有智能体组件必须遵循的、唯一的 Props 契约。

```
/**
 * 智能体可交互组件的标准 Props 接口
 */
export interface ToolcallComponentProps<
  TArgs extends object = any,
  TResult = any,
  TResponse = any
> {
  /** 组件的当前渲染状态: 'idle' | 'inProgress' | 'executing' | 'complete' | 'error' */
  status: 'idle' | 'inProgress' | 'executing' | 'complete' | 'error';
  /** Agent 调用时传入的初始参数 */
  args: TArgs;
  /** 当 status 为 'complete' 时，包含 Action 的最终执行结果 */
  result?: TResult;

  /** 当 status 为 'error' 时，包含错误信息 */
  error?: Error;
  /**
   * 【交互核心】一个回调函数，用于将用户的交互结果返回给宿主环境。
   * 仅在“交互式”场景下由宿主提供。
   */
  respond?: (response: TResponse) => void;
}
```

### 3.2. Action 配置接口：AgentToolcallConfig

这是方案的核心，它通过 TypeScript 的联合类型定义了两种 Action 模式。

```
import { ToolcallComponentProps } from './agent-spec';
// 场景一：非交互式 Action 的配置 (有 handler)
interface NonInteractiveActionConfig<TArgs, TResult> {
  name: string;
  description: string;
  parameters: any[];
  /** 业务逻辑执行器 */
  handler: (args: TArgs) => Promise<TResult>;
  /** 状态显示组件 */
  component: React.FC<ToolcallComponentProps<TArgs, TResult>>;
}
// 场景二：交互式 Action 的配置 (无 handler)
interface InteractiveActionConfig<TArgs, TResult, TResponse> {
  name: string;
  description: string;
  parameters: any[];
  /** 交互式UI组件 */
  component: React.FC<ToolcallComponentProps<TArgs, TResult, TResponse>>;
  /** handler 属性不存在，以此作为区分标志 */
  handler?: never;
}
// 最终的配置类型
export type AgentToolcallConfig<TArgs, TResult, TResponse> =
  | NonInteractiveActionConfig<TArgs, TResult>
  | InteractiveActionConfig<TArgs, TResult, TResponse>;
```

## 4. 统一智能适配器：useAgentAction

这个统一的适配器取代了之前的两个。它通过检查配置对象中是否存在 handler，智能地桥接到 CopilotKit 对应的模式。

```
// agent-unified-adapter.ts
import React from 'react';
import { useCopilotAction } from "@copilotkit/react-core";
import { AgentToolcallConfig } from './agent-config-spec';
import { ToolcallComponentProps } from './agent-spec';
// 类型守卫：判断是否为非交互式配置
function isNonInteractive<TArgs, TResult>(
  config: any
): config is { handler: (args: TArgs) => Promise<TResult> } {
  return typeof config.handler === 'function';
}
/**
 * 统一的、智能的 Agent Action 适配器 Hook
 */
export function useAgentToolcall<TArgs, TResult, TResponse>(
  config: AgentToolcallConfig<TArgs, TResult, TResponse>
) {
  const { name, description, parameters, component } = config;
  // **智能判断的核心**
  if (isNonInteractive<TArgs, TResult>(config)) {
    // 模式一：非交互式 -> 桥接到 handler + render
    useCopilotAction<any>({
      name, description, parameters,
      handler: config.handler,
      render: (props) => {
        const agentProps: ToolcallComponentProps<TArgs, TResult> = {
          status: props.status,
          args: props.args as TArgs,
          result: props.result,
          error: props.error,
        };
        return React.createElement(component, agentProps);
      },
    });
  } else {
    // 模式二：交互式 -> 桥接到 renderAndWaitForResponse
    useCopilotAction<any>({
      name, description, parameters,
      renderAndWaitForResponse: (props) => {
        const agentProps: ToolcallComponentProps<TArgs, TResult, TResponse> = {
          status: props.status,
          args: props.args as TArgs,
          result: props.result,
          error: props.error,
          respond: props.respond,
        };
        return React.createElement(component, agentProps);
      },
    });
  }
}
```

## 5. 使用示例

### 5.1. 场景一：非交互式组件 (状态显示)

用例: Agent 需要执行一个耗时的后台任务（如生成报 u 告），并实时在前端展示任务状态。组件仅作为“状态显示器”。

组件代码: ReportGeneratorStatus.tsx

```
import React from 'react';
import { ToolcallComponentProps } from './agent-spec';
// 定义组件所需的数据类型
type ReportArgs = {
  reportType: 'sales' | 'users';
  dateRange: { start: string; end: string; };
};
type ReportResult = {
  downloadUrl: string;
  recordCount: number;
};
// 实现组件，它根据 props 的变化渲染不同状态的 UI
export const ReportGeneratorStatus: React.FC<ToolcallComponentProps<ReportArgs, ReportResult>> = ({
  status,
  args,
  result,
  error
}) => {
  switch (status) {
    case 'inProgress':
      return <div>⏳ 正在准备生成 {args.reportType} 报告...</div>;
    case 'executing':
      return (
        <div>
          🔄 正在生成报告...
          <p>类型: {args.reportType}</p>
          <p>日期范围: {args.dateRange?.start} - {args.dateRange?.end}</p>
        </div>
      );
    case 'complete':
      return (
        <div>
          ✅ 报告生成完成!
          <p>共包含 {result?.recordCount} 条记录。</p>
          <a href={result?.downloadUrl} target="_blank" rel="noopener noreferrer">
            点击下载报告
          </a>
        </div>
      );
    case 'error':
      return <div>❌ 报告生成失败: {error?.message}</div>;
    default:
      return <div>报告任务已创建。</div>;
  }
};
```

Action 配置与使用

```
// actions/report.action.ts
import { AgentToolcallConfig } from '../specs';
import { ReportGeneratorStatus } from '../components/ReportGeneratorStatus';
export const generateReportAction: AgentToolcallConfig = {
  name: "generateReport",
  description: "生成一份指定类型和日期范围的数据报告",
  parameters: [
    { name: "reportType", type: "string", enum: ['sales', 'users'], required: true },
    { name: "dateRange", type: "object", required: true, properties: [
      { name: "start", type: "string", description: "ISO 格式的开始日期" },
      { name: "end", type: "string", description: "ISO 格式的结束日期" },
    ]}
  ],
  // 业务逻辑和UI组件内聚在一个配置中
  handler: async (args: ReportArgs) => {
    console.log("开始生成报告:", args);
    // const report = await reportService.create(args);
    // return { downloadUrl: report.url, recordCount: report.count };
    await new Promise(resolve => setTimeout(resolve, 2000)); // 模拟耗时
    return { downloadUrl: "#", recordCount: 125 };
  },
  component: ReportGeneratorStatus,
};
// features/MyReportFeature.tsx
import { useAgentToolcall } from '../adapter';
import { generateReportAction } from '../actions/report.action';
function MyReportFeature() {
  // 调用非常简洁，适配器会根据 handler 的存在自动选择正确模式
  useAgentToolcall(generateReportAction);
  return (/* UI to trigger the action */);
}
```

### 5.2. 场景二：简单交互式组件 (用户确认)

用例: Agent 执行一个危险操作前（如删除数据），必须弹出一个对话框，等待用户明确确认或取消。

组件代码: ConfirmDeletionDialog.tsx

```
import React from 'react';
import { ToolcallComponentProps } from './agent-spec';
// 定义组件所需的数据类型
type ConfirmArgs = { itemName: string; itemId: string; };
type ConfirmResponse = { confirmed: boolean; };
type ConfirmResult = ConfirmResponse; // 交互式组件的 Result 通常与 Response 一致
// 实现组件
export const ConfirmDeletionDialog: React.FC<ToolcallComponentProps<ConfirmArgs, ConfirmResult, ConfirmResponse>> = ({
  status,
  args,
  result,
  respond
}) => {
  // 交互阶段：等待用户输入
  if (status === 'executing') {
    return (
      <div className="confirm-dialog">
        <h3>⚠️ 您确定要删除吗？</h3>
        <p>项目: {args.itemName} (ID: {args.itemId})</p>
        <p>此操作不可撤销。</p>
        <div className="button-group">
          {/* 调用 respond 将用户的选择返回给 Agent */}
          <button onClick={() => respond?.({ confirmed: true })}>确认删除</button>
          <button onClick={() => respond?.({ confirmed: false })}>取消</button>
        </div>
      </div>
    );
  }
  // 完成阶段：显示用户的最终选择
  if (status === 'complete') {
    return (
      <div>
        {result?.confirmed
          ? `✅ 您已确认删除项目 ${args.itemName}。`
          : `ℹ️ 您已取消了删除操作。`}
      </div>
    );
  }
  // 准备阶段
  return <div>⏳ 正在加载确认信息...</div>;
};
```

Action 配置与使用

```
// actions/deletion.action.ts
import { AgentToolcallConfig } from '../specs';
import { ConfirmDeletionDialog } from '../components/ConfirmDeletionDialog';
export const deleteItemAction: AgentToolcallConfig = {
  name: "deleteItem",
  description: "请求用户确认删除指定项目",
  parameters: [
      { name: "itemName", type: "string", required: true },
      { name: "itemId", type: "string", required: true },
  ],
  // 没有 handler，适配器会自动识别为交互式
  component: ConfirmDeletionDialog,
};
// features/MyDataGrid.tsx
import { useAgentToolcall } from '../adapter';
import { deleteItemAction } from '../actions/deletion.action';
function MyDataGrid() {
  // 调用方式与非交互式完全一致
  useAgentToolcall(deleteItemAction);
  return (/* UI to trigger the action */);
}
```

### 5.3. 场景三：复杂交互式组件 (文件上传)

用例: Agent 需要用户上传一个文件，组件内部需要处理文件选择、读取、校验等复杂逻辑，然后将文件内容返回。

组件代码: FileUpload.tsx

```
import React, { useState, useCallback } from 'react';
import { ToolcallComponentProps } from './agent-spec';
// 定义数据类型
type UploadArgs = {
  allowedTypes: string[]; // e.g., ['image/png', 'application/pdf']
  maxSizeMB: number;
};
type UploadResponse = {
  success: boolean;
  fileName?: string;
  fileContent?: string; // Base64 encoded
  error?: string;
};
type UploadResult = UploadResponse;
// 实现组件，包含内部状态管理
export const FileUpload: React.FC<ToolcallComponentProps<UploadArgs, UploadResult, UploadResponse>> = ({
  status,
  args,
  result,
  respond
}) => {
  const [internalError, setInternalError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const handleFileChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
    if (!args.allowedTypes.includes(file.type)) {
      setInternalError(`文件类型错误。请上传 ${args.allowedTypes.join(', ')} 格式。`);
      return;
    }
    if (file.size > args.maxSizeMB * 1024 * 1024) {
      setInternalError(`文件过大。请上传小于 ${args.maxSizeMB}MB 的文件。`);
      return;
    }
    setInternalError(null);
    setIsLoading(true);
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      setIsLoading(false);
      respond?.({
        success: true,
        fileName: file.name,
        fileContent: reader.result as string,
      });
    };
    reader.onerror = () => {
      setIsLoading(false);
      respond?.({ success: false, error: '文件读取失败。' });
    };
  }, [args, respond]);
  if (status === 'executing') {
    return (
      <div className="file-uploader">
        <h4>请上传文件</h4>
        <p>允许格式: {args.allowedTypes.join(', ')}</p>
        <p>最大体积: {args.maxSizeMB}MB</p>
        <input type="file" onChange={handleFileChange} disabled={isLoading} />
        {isLoading && <div>🔄 正在读取文件...</div>}
        {internalError && <div style={{ color: 'red' }}>{internalError}</div>}
      </div>
    );
  }
  if (status === 'complete') {
    return (
      <div>
        {result?.success
          ? `✅ 文件 ${result.fileName} 上传成功!`
          : `❌ 文件上传失败: ${result?.error}`}
      </div>
    );
  }
  return <div>⏳ 准备上传...</div>;
};
```

Action 配置与使用

```
// actions/upload.action.ts
import { AgentToolcallConfig } from '../specs';
import { FileUpload } from '../components/FileUpload';
export const uploadFileAction: AgentToolcallConfig = {
  name: "uploadFile",
  description: "请求用户上传一个符合要求的文件",
  parameters: [
      { name: "allowedTypes", type: "array", items: { type: "string" }, required: true },
      { name: "maxSizeMB", type: "number", required: true },
  ],
  // 依然没有 handler
  component: FileUpload,
};
// features/MyUploader.tsx
import { useAgentToolcall } from '../adapter';
import { uploadFileAction } from '../actions/upload.action';
function MyUploader() {
  useAgentToolcall(uploadFileAction);
  return (/* UI to trigger the action */);
}
```

## 6. 方案优势

             1.
     高度内聚 (High Cohesion): 一个 Action 的所有逻辑（业务 handler 和 UI component）都封装在同一个配置对象中，代码组织清晰，维护性极高。
             2.
     API 简化 (Simplified API): 开发者只需学习和使用一个统一的 useAgentToolcall Hook，无需关心底层使用了哪种 CopilotKit 模式，心智负担大大降低。
             3.
     类型安全 (Type-Safe): 通过 TypeScript 的联合类型和类型守卫，适配器可以在编译时就确定使用哪种模式，代码健壮，不易出错。
             4.
     可发现性与可移植性 (Discoverability & Portability): 独立的 Action 配置对象易于被集中管理和动态加载，为未来的“Action市场”或插件化系统奠定了基础。同时，核心组件与框架无关，可轻松移植。
